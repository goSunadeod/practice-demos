## 浏览器渲染原理与全链路性能优化
### 一、进程与进程
进程是操作系统资源分配的基本单位，进程当中包括线程
线程是由进程所管理的，为了提示浏览器的稳定性和安全性，浏览器采用了多进程模型
浏览器多进程模型

浏览器进程：负责界面显示、用户交互、子进程管理、提供存储等
渲染进程：每个也卡都有自己的单独的渲染进程，核心用于渲染界面
网络进程： 主要处理网络资源加载HTML、CSS、JS等
GPU进程： 3d绘制提高性能
插件进程： chrome安装的一些插件
### 二、从输入URL到浏览器显示页面都发生了什么？
用户输入url地址会开始导航，如果输入的是关键字，会根据默认的搜索引擎生成地址会开始导航
浏览器进程会准备一个渲染进程用于渲染页面
通过网络进程加载资源，最终将加载的资源交给渲染进程来处理
渲染完毕显示 ipc -> postmesssage
网络的七层模型

物理层 + 数据链路层 -> 提供光缆等硬件设备以及数据包解析等操作

网络层 -> 解析ip

传输层 ->采用tcp协议（安全可靠，分段传输）或者UDP协议（可能会出现丢包的现象，但是速度快）

会话层 + 表示层 + 应用层 -> 采用http协议

先去查找缓存，检测缓存是否过期，没有直接返回缓存中的内容

看域名是否被解析过，DNS协议将域名解析成ip地址，DNS是一个映射表（IP地址与域名的映射表），DNS解析是基于UDP的，（ip+端口host）

请求是https，ssl协商

IP地址来寻址，排队等待，最多能发送6哥请求

tcp创建链接，用于传输（经过三次握手）

利用tcp输出数据（拆分成数据包 有序） 可靠、有序，服务器会按照顺序进行重排

http请求，请求行、请求头、请求体

默认不会断开 keep-slive 为例下次传输数据时可以复用上次创建的链接

服务器接收到数据之后，进行解析，相应行、相应头、响应体

服务器的状态码

http0.9 文本协议

http1.0 提供来http的header 根据header进行处理不同的请求

http1.1 默认开启keep-alive 链接服用 管线化（一次性发6个请求），服务器每次只能按照顺序进行处理单个请求（会造成对头阻塞问题）

http2.0 通过二进制的方式进行传输，用同一个tcp链接来发送数据， 一个域名一个tcp（多路复用），具有头部压缩（通过hpack），服务器具有主动推送数据给客户端

http3.0 解决传输过程中tcp的队头阻塞问题（tcp在传输的过程中丢包就要重新发，后面的请求就要等待），采用udp + QUIC协议

渲染流程，浏览器

浏览器无法直接使用HTML、需要将HTML转化成DOM树
浏览器无法解析纯文本的css样式，需要对css进行解析解析成stylesheets。CSSDOM
计算出DOM树中每一个节点的具体样式
创建渲染（布局）树，将DOM树中可见节点添加到布局树中，并计算节点渲染到页面的坐标位置